# 继承
继承使得用以前的代码非常容易，能够大大缩短开发周期，降低开发成本，同时增加程序的易维护性。   
继承是面向对象的三大特征之一，是JAVA中实现代码重用的重要手段之一，它的作用是在已有的类的基础之上进行扩充或改造，得到新类；
## 继承：
简单的说，继承，就是能够让一个类（A类）直接使用另外一个类（B类）的属性和方法的途径；并且这个类（A类）还可以有自己的属性和方法；  
### 继承的语法：
类的继承：
```java
修饰符 class SubClass extends SuperClass {
                 //类定义部分
}
```
如：   
```java
public  class PersonnelDept extends Department {
  ............................
  }
```
修饰符：如，public；        
SubClass :代表的是子类的类名；     
extends关键字：      
SuperClass:代表的是父类的类名；   

在JAVA中，只支持单继承，每个类只能有一个直接父类；（一个儿子可能有好几个干爹，但，他只有一个亲生父亲；）
继承表达的关系是 is a 的关系；或者说，是一种特殊和一般的关系；

##### 子类继承的父类的什么？
一，继承public和protected修饰的属性和方法，不管子类和父类是否在同一个包里；   
二，继承默认权限修饰符修饰的属性和方法，但子类和父类必须在同一个包里；    
##### 注意：
子类无法继承private修饰的属性和方法；   
子类无法继承父类的构造方法；     

子类可以继承父类的属性和方法，还可以有自己的属性，但是调用父类继承的方法却不能获取自己的私有属性，方法；     
如果从父类继承的方法不能满足子类的需求，在子类中可以对父类的同名方法进行重写；    
#### 方法的重写：
也可以称为方法的覆盖；    
是指子类中根据需求对父类继承来的方法进行重新编写；   
在重写方法时，从访问修饰符，返回值类型，方法名到参数列表，和继承来的方法都是一样的，只是方法体的内容不一样；    
如果在重写时，我们想保留父类的方法，可以通过关键字 
super.方法名来调用；      

##### 方法的重载：
在一个类中，有多个方法的方法名形同，但参数的个数和类型不同；     
##### 方法的重写：
在子类对父类的方法进行重写；

##### 方法重写必须满足的几个要求：
第一，必须具有相同的方法名；   
第二，必须具有相同的参数列表；   
第三，返回值类型必须相同或者是其子类；    
第四，不能缩小被重写方法的访问权限；    

通过快捷方式，找到要重写的方法；   
在指定区域，单击右键-> Source -> Overrid/...     
当子类重写了由父类继承来的方法后，那么，子类对象优先调用的就是重写的方法；     

如果使用了方法重写，但是又想调用父类的被重写了的方法，？？？
#####  关键字super：     
super代表当前对象的直接父类对象的默认引用；     
在使用super这个关键字的时候，需要注意以下几项：       
- super必须是出现在子类中（子类的方法和构造方法中），而不是其他位置；
- super是用以访问父类的成员，例如父类的属性，方法，构造方法等；
- super在访问权限上也有限制，例如无法通过super访问由private修饰的成员，   
小解super：    
Super关键字和以前所学过的this关键字作用类似，都是讲屏蔽了的成员变量、成员方法变为可见可用，也就是说用来引用被屏蔽的成员变量或成员方法；不过，super是用在子类中，目的是访问直接父类中被屏蔽的内容；     
   确切的说，我们可以这样来解释super关键字：super代表当前对象的直接父类的默认引用。在子类中可以通过super关键字来访问父类的成员；


###  构造方法：
- 构造方法必须和所在类同名；
- 构造方法定义时不需指定返回类型；
为了子类能够使用父类的属性，在初始化子类的时候，也需要同时初始化父类的属性；   
#### 继承条件下的构造方法的调用规则：
- 规则一：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法；    
- 规则二：
如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应的构造方法，而不执行父类无参构造方法；
- 规则三：
如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则；    

当我们的类中显式的创建了有参或无参的构造方法，系统就不会再为这个类创建一个无参的构造方法了；（即使父类有有参，也不调用）；   

当我们的子类构造方法中即使没有显示调用父类的构造方法，系统也会默认的去调用父类当中无参的构造方法；    

调用父类的方法或属性： super.方法  super.属性     
调用父类的构造方法：  super（）；（无参）     
super（参数列表）； （有参）    
调用自身的其他构造方法：  this();  无参；    
this（参数列表）；有参    

`注意：在构造方法中，使用super关键字时，super关键字一定要放在第一行；`

##### Object类：
`Object`类是所有类的父类；       
我们在定义类没有指定继承自哪个类时，在编译时编译器自动令其继承`java.lang`包中的Object类；        
在JAVA中，所有的JAVA类都直接或间接地继承了`java.lang.Object`类；Object类是所有JAVA类的祖先；在定义一个类时，如果没有使用extends关键字，那么这个类也直接继承了Object类，所有的对像，包括数值，都继承这个类的方法，Object类定义了大量的可被其他类继承的方法；

相等的属性值：两个对象具有相同的类型、相同的属性值；   
同一个引用对象：两个引用对象指向同一个对象，即指向同一个地址；   

Object类的`equals()`方法比较的是，两个对象是否是同一个应用对象，是则返回true；    

操作符“==”也可以来判断是否相等，这个双等号操作符两边的表达式可以是基本数据类型，比如数字，字符等，也可以是对象等引用数据类型；     
如果是基本数据类型，比较的就是他们的值了；如果是引用数据类型，比较的就是，是否指向同一个引用对象；     
所有，如果单纯的使用Object类的equals（）方法来比较对象是否是一个引用对象，那么是跟操作符“==”没有区别的；    

在实际的开发中，往往不是直接拿来用这些方法，而是要重写后再使用，
为什么要重写equals（）方法？     
在实际开发中，不仅仅是判断两个对象引用是否相等，两个基本数据类型值相等，有时可能要同时来判断两个对象的多个属性值是否相等，来判断这两个对象是否相等；故需要重写；     
```java
String str1 = new String("china");
String str2 = new String("china");
System.out.println(str1.equals(str2));
```
结果为：true

equals()方法是比较是否是同一对象，为什么结果会是true？    
因为，String重写了equals方法，把原来判断是否是同一个对象的equals（）方法，变成了值的比较；    

Object类常用的，也是被它的子类经常重写的方法：  

|方法                           |    说明|
|----|-----|
|toString（）  | 返回当前对象本身的相关信息，按字符串对象返回；|
|equals（）     |比较两个对象是否是同一个对象，是则返回true；|
|clone（）      |生成当前对象的一个拷贝，并返回；|
|hashCode（）   |返回该对象的哈希代码值；|
|getClass（）  | 获取当前对象所属的类信息，返回Class对 象；|



